# 智能指针

我们之前简单介绍过指针，这里还是先回顾一下：指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；引用是一个特殊的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用。

那什么是智能指针呢？

在指针和引用的基础上，Rust 偷师 C++，提供了智能指针。智能指针是一个表现行为很像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。这个定义有点模糊，我们对比其他的数据结构来明确一下。你有没有觉得很像之前讲的胖指针。智能指针一定是一个胖指针，但胖指针不一定是一个智能指针。比如 &str 就只是一个胖指针，它有指向堆内存字符串的指针，同时还有关于字符串长度的元数据。

String 除了多一个 capacity 字段，似乎也没有什么特殊。**但 String 对堆上的值有所有权，而 &str 是没有所有权的，这是 Rust 中智能指针和普通胖指针的区别。**

所以再清晰一下定义，**在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。**

以下这些结构都是智能指针：

- String
- Box<T>
- Vec<T>
- Rc<T>, Arc<T>
- Ref<T>, RefMut<T>, RefCell<T>
- PathBuf
- Cow<'a, B>
- MutexGuard<T>, RwLockReadGuard<T>, RwLockWriteGuard

## Box<T>
在Rust中，所有值默认都是栈上分配。通过创建Box<T>，可以把值装箱，使它在堆上分配。
Box<T>类型是一个智能指针，因为它实现了`Deref trait`，它允许Box<T>值被当作引用对待。当Box<T>值离开作用域时，由于它实现了`Drop trait`，首先删除其指向的堆数据，然后删除自身。

Deref这个trait, 允许我们重载解引用运算符*。实现Deref的智能指针可以被当作引用来对待，也就是说可以对智能指针使用*运算符进行解引用。

Box<T>对Deref的实现：
```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> Deref for Box<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &**self
    }
}
```
该实现返回`&**self`。为什么呢？由于`self`是一个`&Box<T>`，因此对其进行一次解引用`*`将获得一个`Box<T>`，而第二次解引用`*`将获得一个`T`。最后，将其包装在引用`&`中并返回。

注：如果是我们自定义的类型，要实现deref，则不能仿照它，否则会造成无限递归。

Box<T>是堆上分配的指针类型，称为“装箱”（boxed），其指针本身在栈，指向的数据在堆，在Rust中提供了最简单的堆分配类型。使用Box<T>的情况：

递归类型和trait对象。Rust需要在编译时知道一个类型占用多少空间，Box<T>的大小是已知的。
“大”的数据转移所有权。用Box<T>只需拷贝指针。

递归类型的经典示例：
```rust
use List::{Cons, Nil};

#[derive(Debug)]
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}

fn main() {
    let recursive_list: List<i32> = Cons(1, Box::new(Cons(2, Box::new(Nil))));
    println!("{:?}", recursive_list); // 打印出: Cons(1, Cons(2, Nil))
}
```

trait对象的示例：
```rust
trait T {
    fn m(&self) -> u64;
}

struct S {
    i: u64
}

impl T for S {
    fn m(&self) -> u64 { self.i }
}

fn f(x: Box<dyn T>) {
    println!("{}", x.m())
}

fn main() {
    let s = S{ i: 100 };
    println!("{}", s.m());

    let b: Box<S> = Box::new(S{i:100});
    f(b); // 动态调用
}
```

自定义的类型的Deref实例：
```rust
use std::ops::Deref;

#[derive(Debug)]
struct MyBox<T> {
    value: T,
}

impl<T> Deref for MyBox<T> {
    type Target = T;

fn deref(&self) -> &Self::Target {
    &self.value
  }
}

fn main() {
    let instance = MyBox{value: 10};
    assert_eq!(10, *instance);
    println!("{}, {}", *instance, *(instance.deref()));
}
```

## Cow<'a, B>
